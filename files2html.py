#Импорт встроенной библиотеки os
import os
#Импорт модуля request из встроенной библиотеки urllib
from urllib import request

#Строка-адрес документов на сервере сайта
pdf_path = 'assets/files/education_doc/08_03_01/praktika/2021/'

#Массив, в который будут сохранены названия документов
# в текстовом и punycode-виде во время работы скрипта
pdf_data = []

#Данная конструкция, есть как бы аналог функции main() из C++ и выполняется,
# если скрипт запущен напрямую, а не импортирован (особенность Python)
if __name__ == '__main__':
	# Часть 1. Формирование списка pdf-файлов в директории расположения скрипта.
	#
	#os.listdir() возвращает массив имён всех файлов и подпапок из указанной
	# директории, в данном случае - директории выполнения скрипта ('.')
	#
	#Собственно, код внутри цикла for выполняется для каждого имени из массива,
	# возвращённого функцией listdir, т.е. для каждого имени файла/подпапки
	#
	#Текущий объект из массива сохраняется в переменную pdf на текущую
	# итерацию цикла
	for pdf in os.listdir('.'):
		#Проверка: последние три символа имени объекта, переведённого
		# в нижний регистр (ф-ия lower()), равны ли 'pdf'?
		if pdf[-3:].lower() == 'pdf':
			#Если вышестоящее условие выполнено, то тогда в переменную doc_name
			# сохраняется имя pdf-файла без расширения (т.е. без последних
			# четырёх символов '.pdf')
			doc_name = pdf[:-4]
			
			#В массив pdf_data добавляется элемент, состоящий из двух объектов:
			# 1) имя файла без расширения (переменная doc_name)
			# 2) полное имя файла, переведённое в punycode в кодировке utf-8
			# (Почему UTF-8? Потому, что в MODX она используется для ссылок)
			#
			#Преобразование в punycode выполняется методом quote() модуля request
			pdf_data.append([doc_name, request.quote(pdf.encode('utf8'))])
	
	# Часть 2. Запись списка pdf-файлов в текстовый документ в ту же папку.
	# Зачем это нужно? Для контроля имён длинных файлов на орфографические ошибки.
	#
	#При помощи метода with open() создаётся новый файл '_list.txt' в кодировке
	# UTF-8; если файл существует, то он перезаписывается новым пустым файлом
	with open('_list.txt','w', encoding='utf-8') as file:
		#Из каждого элемента массива pdf_data в файл записывается строка вида
		# '<name>.pdf\n', где <name> - первый объект элемента массива, то есть
		# имя pdf-файла без расширения '.pdf', т.к. оно было удалено ранее.
		# \n обозначает перенос на следующую строку, без него все имена будут
		# записаны в одну строку.
		for doc in pdf_data:
			file.write('{}.pdf\n'.format(doc[0]))
		#при использовании with open() закрывать файл не нужно
		
	# Часть 3. Оформление и запись списка pdf-файлов в html-документ.
	#
	#При помощи метода with open() создаётся новый файл '_list.html' в кодировке
	# UTF-8; если файл существует, то он перезаписывается новым пустым файлом
	with open('_list.html','w', encoding='utf-8') as file:
		
		#Сначала в файл записывается строка-заголовок, в данном случае это 
		# 'Рабочие программы практик...' внутри html-тега <p>
		file.write('<p>Рабочие программы практик за 2021 год:</p>\n')
		
		#Далее в файл записывается открывающий тег списка - <ul>
		file.write('<ul>\n')
		
		#Наконец, в файл записываются все ранее найденные  pdf. В файл сохраняются строки
		# вида '<li><a href="%путь%%ссылка%">%имя_файла%</a></li>\n', где
		# %путь% - это значение переменной pdf_path, т.е. расположение файлов на сервере
		# %ссылка% - это полное название pdf-файла (с расширением '.pdf') в punycode-виде
		# %имя_файла% - это имя файла без его расширения ('.pdf')
		for doc in pdf_data:
			file.write('<li><a href="{}{}">{}</a></li>\n'.format(pdf_path, doc[1], doc[0]))
		
		#Затем в файл записывается закрывающий тег списка - </ul>, после чего работа скрипта завершается.
		file.write('</ul>\n')
